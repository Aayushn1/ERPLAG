/*
GROUP 41
2016B2A70803P 	MANNAT KHURANA
2017A7PS0137P	PRAKALP TIWARI
2017A7PS0215P	JHAVERI AYUSH RAJESH
2017A7PS0219P	AAYUSH NAGPAL
*/


#include"codegen.h"
#include <stdio.h>
#include "parser.h"
#include"typechecker.h"
#include<time.h>

int main(int argc,char** argv){
	printf("\n");

	clock_t start_time, end_time;
    double total_CPU_time = 0.0, total_CPU_time_in_seconds = 0.0;
	
	if(argc < 3)
		printf("Too few arguments. \n");
	else{

		fclose(fopen("errors.txt","w"));
		int highestOperation = 0;
		Token* t = NULL;
		rule* rules[no_rules];
		term_sets* termSetsArr[no_tnt];
		int** parseTable = NULL;
		tNode* parseTreeRoot = NULL;
		int option;
		scopeNode* tableRoot;
		long int no_parse, no_ast;
		FILE* errorFile = fopen("errors.txt","a");
		char errors[100];
		bool inputError = false;

		do{
			printf("\n-------------------------------------------------------------------------------------------------\n");
			printf("LEVEL 4: Symbol table/type Checking/ Semantic rules module(s) work(s)/ handled static and dynamic arrays in type checking and code generation\n");
			printf("\nPress option for the defined task\n");
			printf("0.\tQuit\n");
			printf("1.\tPrint the token list generated by the lexer\n");
			printf("2.\tParse the source code to verify the syntactical correctness and print parse tree\n");
			printf("3.\tPrint the AST\n");
			printf("4.\tMemory Usage\n");
			printf("5.\tPrint the Symbol Table\n");
			printf("6.\tPrint Activation Record size\n");
			printf("7.\tPrint the Static and Dynamic arrays\n");
			printf("8.\tError Reporting and Compile time\n");
			printf("9.\tCode Generation\n");

			scanf("%d",&option);

			switch(option){
				case 0:{
					//fclose(fopen("errors.txt","w"));
					printf("\n\nExiting...\n");
					break;
				}
				
				case 1:{
					start_time = clock();
					initializeLexer(argv[1],errorFile);
					Token* t;
					t = getNextToken();
					while (strcmp(t->tokenName, "$") != 0)
					{
						if (strcmp(t->lexeme, "") != 0)
							printf("Line: %d\t\tLexeme: %s\t\tToken: %s\n", t->lineNo, t->lexeme, t->tokenName);
						t = getNextToken();
					}
					printf("\n\n\n");
					highestOperation = highestOperation > 1 ? highestOperation : 1;
					end_time=clock();
					total_CPU_time  +=  (double) (end_time - start_time);
					total_CPU_time_in_seconds +=   total_CPU_time / CLOCKS_PER_SEC;
					if(lexerErrors) {
						printf("Errors found during lexical analysis\n");
						printf("Press 8 to view the errors\n");
					}
					break;
				}
				case 2:{
					if(highestOperation >= 1){
					start_time = clock();
   					populateRules(rules,"grammar.txt");
			
					for(int i=0;i<no_tnt;i++){
						termSetsArr[i] = (term_sets*)malloc(sizeof(term_sets));
						termSetsArr[i]->FIRST = 0;
						termSetsArr[i]->FOLLOW = 0;
						termSetsArr[i]->token = (tnt)i;
					}
					populateFIRST(rules,termSetsArr);
					populateFOLLOW(rules,termSetsArr);
					parseTable = initParseTable(parseTable);
					populateParseTable(parseTable,rules,termSetsArr);
					fclose(errorFile);
					errorFile = fopen("errors.txt","w");
					parseTreeRoot = parseInputSourceCode(argv[1],parseTable,rules,termSetsArr,errorFile);
					fclose(errorFile);
					errorFile = fopen("errors.txt","a");
					printf("lexemeCurrentNode\tlineno\t\ttoken\t\tvalueIfNumber\tparentNodeSymbol\tisLeafNode(yes/no)\tNodeSymbol\n");
					printParseTree(parseTreeRoot);
					printf("\n\n\n");
					no_parse = countParseTree(parseTreeRoot);
					highestOperation = highestOperation > 2 ? highestOperation : 2;
					end_time=clock();
					total_CPU_time  +=  (double) (end_time - start_time);
					total_CPU_time_in_seconds +=   total_CPU_time / CLOCKS_PER_SEC;
					if(parserErrors){
						printf("\nParser errors\nPlease press 8 to view all errors\n");
					}
				}
					else
					{
						printf("\nPlease perform lexical analysis first!\n");
					}
					
					break;
				}

				case 3:{
					if(highestOperation>=2){
						start_time=clock();
						parseTreeToAST(&parseTreeRoot,rules);
						printf("lexemeCurrentNode\tlineno\ttoken\t\t\tvalueIfNumber\tparentNodeSymbol\tisLeafNode(yes/no)\tNodeSymbol\n");
						printParseTree(parseTreeRoot);
						printf("\n\n\n");
						no_ast = countParseTree(parseTreeRoot);
						highestOperation = highestOperation > 3 ? highestOperation : 3;
						end_time=clock();
						total_CPU_time  +=  (double) (end_time - start_time);
						total_CPU_time_in_seconds +=   total_CPU_time / CLOCKS_PER_SEC;
						if(parserErrors){
						printf("\nParser errors\nPlease press 8 to view all errors\n");
						}
					}
					else
						printf("\nPlease perform syntactical analysis first!\n");
					break;
				}
				case 4:{
					if(highestOperation >= 3){
						printf("Parse Tree: Number of Nodes = %ld, Allocated Memory = %ld bytes\n",no_parse,(long int)(no_parse*sizeof(tNode)));
						printf("AST       : Number of Nodes = %ld, Allocated Memory = %ld bytes\n",no_ast,(long int)(no_ast*sizeof(tNode)));
						printf("Percent Compression = %f%%\n",(((float)no_parse-(float)no_ast)/(float)no_parse)*100.0);
						highestOperation = highestOperation > 4 ? highestOperation : 4;
					}
					else
						printf("\nPlease perform AST creation first!\n");
					break;
				}

				case 5:{
					if(highestOperation>=3){
						if(parserErrors || lexerErrors){
							printf("\nLexer and Parser errors in code\nUse option 8 to print errors\n");
						}
						else{
							start_time=clock();
							initializeSymbolTable(errorFile);
							tableRoot = createSymbolTable(parseTreeRoot);
							printf("\n\nVariable_Name\tScope(Module_Name)\tScope(Line_Numbers)\tWidth\tisArray(Y/N)\tStatic_or_Dynamic\tRange_Lexemes\tType_of_Element\tOffset\tNesting_Level\n");						
							printSymbolTable(tableRoot);
							highestOperation = highestOperation > 5 ? highestOperation : 5;
							initSemanticAnalysis(errorFile);
							semantic_analysis(parseTreeRoot);
							end_time=clock();
							total_CPU_time  +=  (double) (end_time - start_time);
							total_CPU_time_in_seconds +=   total_CPU_time / CLOCKS_PER_SEC;
						}
						
					}
					else
						printf("\nPlease perform AST creation first!\n");

					break;
				}
				case 6:{
					if(highestOperation>=5){
						printf("Activation Records:\n\n");
						printf("Module Name \t\t Record Size\n");
						printActivationRecords(tableRoot);
						highestOperation = highestOperation > 6 ? highestOperation : 6;
					}
					else
						printf("\nPlease perform Symbol Table creation first!\n");

					break;
				}
				case 7:{
					if(highestOperation>=5){
						printf("\n\nModule\t\t\tScope\t\tName\t\tArray Type\tArray Range\tElement Type\n");
						printf("\n\nScope(Module_Name)\tScope(Line_Numbers)\tVariable_Name\tStatic_or_Dynamic\tRange_Lexemes\tType_of_Element\n");
						printArrays(tableRoot);
						highestOperation = highestOperation > 7 ? highestOperation : 7;
					}
					else
						printf("\nPlease perform Symbol Table creation first\n");

					break;
				}
				case 8:{
						
						fclose(errorFile);
						FILE* ptr = fopen("errors.txt","r");

						if(parserErrors!=0)
						{
							inputError = true;//ho gaya mkc vandana ki//yayyyy nagpal GOD par 11 errors hone chahiye yaha zyada h
							int temp = parserErrors + lexerErrors;
							if(parserErrors)
								printf("Errors:\n");
							while(temp--){
								fgets(errors,150,ptr);
								printf("%s",errors);
								
							}
						}
						else if(lexerErrors!=0){
							int temp = lexerErrors;
							if(lexerErrors)
								printf("Lexer Errors:\n");
							while(temp--){ 
								fgets(errors,150,ptr);
								printf("%s",errors);
							}
						}

						else if(symbolTableErrors!=0 || typeCheckErrors!=0){
							
							inputError = true;
							int temp = symbolTableErrors;
							printf("Semantic Errors:\n");
							while(temp--){
								fgets(errors,150,ptr);
								printf("%s",errors);
							}
							temp = typeCheckErrors;
							while(temp--){
								fgets(errors,150,ptr);
								printf("%s",errors);
							}
							fclose(ptr);
							errorFile = fopen("errors.txt","a");
						}	
						else{
							printf("Code compiles successfully........\n");
						}
						//highestOperation = highestOperation > 8 ? highestOperation : 8;
						printf("\n\n");
						printf("total_CPU_time: %lf\n",total_CPU_time);
						printf("total_CPU_time_in_seconds: %lf\n",total_CPU_time_in_seconds);
						break;
				}
				case 9:{
					if(highestOperation>=5){
						if(!inputError) {
							gen_code_util(argv[2],parseTreeRoot,tableRoot);
							printf("Code has been succesfully generated into the file %s\n", argv[2]);
							printf("If name of asm file is code.asm then run the command: nasm -felf64 code.asm && gcc -g -no-pie code.o && ./a.out\n\n");
						}	
						else
							printf("\nCode cannot be generated as input has errors\n");
						highestOperation = highestOperation > 9 ? highestOperation : 9;	
					}
					else
						printf("\nPlease perform Semantic Analysis first!\n");

					break;
				}

				default:{
					printf("\nPlease choose a valid option\n");
					//scanf("%d",&option);
					break;
				}
				
			}
		}
		while(option!=0);
	}	
}
